name: AWS Batch Prod (Manual)

on:
  workflow_dispatch:

env:
  MASTER_DEPLOY_KEY: ${{ secrets.MASTER_DEPLOY_KEY }}
  AWS_SECRET_ID: ${{ secrets.AWS_SECRET_ID }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_BANKING_PROD }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_BANKING_PROD }}
  GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
  GHCR_USER: ${{ secrets.GHCR_USER }}
  CI_PIPELINE_ID: ${{ github.run_id }}

jobs:

  verify:

    defaults:
      run:
        shell: bash

    name: Verificando...
    runs-on: ubuntu-latest

    steps:
      - name: Error - Verificação Cancelada!
        if: ${{ github.ref != 'refs/heads/main' }}
        run: |
          echo "Por favor, execute este job somente na branch main!!!"
          exit 1

      - name: Verificação Concluída!
        if: ${{ github.ref == 'refs/heads/main' }}
        run: |
          echo "Verificação concluída! Update em andamento..."

  batch:

    defaults:
      run:
        shell: bash

    name: Check AWS Batch
    environment: prod
    runs-on: ubuntu-latest
    needs: verify

    container:
     image: ghcr.io/maistodos/kitkat:latest
     credentials:
       username: ${{ secrets.GHCR_USER }}
       password: ${{ secrets.GHCR_TOKEN }}

    steps:

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Check if Compute Environment exists
      id: check-ce
      run: |
        source /kitkat/ci/inject_env.sh
        source /kitkat/ci/github/ssh_auth.sh
        if aws batch describe-compute-environments --compute-environment $COMPUTE_ENVIRONMENT_NAME --query 'computeEnvironments[0].computeEnvironmentName' --output text | grep -q $COMPUTE_ENVIRONMENT_NAME; then
          echo "Compute Environment exists."
          echo "::set-output name=ce_exists::true"
        else
          echo "Compute Environment does not exist."
          echo "::set-output name=ce_exists::false"
        fi
  
    - name: Create AWS Batch Compute Environment
      if: steps.check-ce.outputs.ce_exists == 'false'
      run: |
        source /kitkat/ci/inject_env.sh
        source /kitkat/ci/github/ssh_auth.sh
        aws batch create-compute-environment \
          --compute-environment-name $COMPUTE_ENVIRONMENT_NAME \
          --type MANAGED \
          --state ENABLED \
          --compute-resources '{"type": "FARGATE", "maxvCpus": 2, "subnets": ["'$SUBNET_ID'"], "securityGroupIds": ["'$SECURITY_GROUP_ID'"]}'
  
    - name: Check if Job Queue exists
      id: check-jq
      run: |
        source /kitkat/ci/inject_env.sh
        source /kitkat/ci/github/ssh_auth.sh
        if aws batch describe-job-queues --job-queues $JOB_QUEUE_NAME --query 'jobQueues[0].jobQueueName' --output text | grep -q $JOB_QUEUE_NAME; then
          echo "Job Queue exists."
          echo "::set-output name=jq_exists::true"
        else
          echo "Job Queue does not exist."
          echo "::set-output name=jq_exists::false"
        fi
  
    - name: Create AWS Batch Job Queue
      if: steps.check-jq.outputs.jq_exists == 'false'
      run: |
        source /kitkat/ci/inject_env.sh
        source /kitkat/ci/github/ssh_auth.sh
        aws batch create-job-queue \
          --job-queue-name $JOB_QUEUE_NAME \
          --state ENABLED \
          --priority 1 \
          --compute-environment-order order=1,computeEnvironment=$COMPUTE_ENVIRONMENT_NAME
        
    - name: Register AWS Batch Job Definition
      run: |
        source /kitkat/ci/inject_env.sh
        source /kitkat/ci/github/ssh_auth.sh
        aws batch register-job-definition \
          --job-definition-name $JOB_DEFINITION_NAME \
          --type container \
          --container-properties '{"image": "'$AWS_ECR':latest", "resourceRequirements": [{"type": "MEMORY","value": "4096"},{"type": "VCPU","value": "2"}], "jobRoleArn": "'$EXECUTION_ROLE_ARN'", "executionRoleArn": "'$EXECUTION_ROLE_ARN'", "networkConfiguration": {"assignPublicIp": "DISABLED"}}' \
          --platform-capabilities FARGATE

          